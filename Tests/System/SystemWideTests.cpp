// Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
// SPDX-License-Identifier: BSD-3-Clause-Clear

#include <cstdint>

#include "Utils.h"
#include "TestUtils.h"
#include "ResourceTunerAPIs.h"

/*
 * These tests mirror the Client Perspective, i.e. how the client interacts with various
 * Resource Tuner APIs like tuneResources / untuneResources, tuneSignal etc.
 * The results of these are evaluated by validating the Resource sysfs Nodes.
 * As part of these Tests Request Verification and Application are Covered.
 * How to run:
 * Option A)
 * - Start a Resource Tuner Server instance in test mode (sudo ./resource_tuner --test)
 * - Run the system tests executable
 * - Upon completion of tests, terminate the server.
 * Option B)
 * - Run the system tests via Script (sudo python pre_commit.py), this script will
 *   automatically start, Run the Tests and then terminate the server.
 */

/*
* Description:
* Handles generated by Resource Tuner Server, serve as Request Idenitfiers.
* A unique handle is generated for each Tune Request (tuneResources and tuneSignal)
* Handle Generation begins from "1" and increments by 1 with each new request.
* Here we submit 3 sequential Requests, and verify that the correct handle is received
* corresponding to each Request, i.e. 1 for R1, 2 for R2 and 3 for R3.
*/
static void TestHandleGeneration() {
    LOG_START

    SysResource* resourceList = new SysResource[1];
    resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 554;

    int64_t handle = tuneResources(2000, 0, 1, resourceList);

    std::cout<<"["<<__LINE__<<"]"<<" Handle Returned: "<<handle<<std::endl;
    assert(handle == 1);

    std::this_thread::sleep_for(std::chrono::seconds(3));

    resourceList = new SysResource[1];
    resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 667;

    handle = tuneResources(2000, 0, 1, resourceList);

    std::cout<<"["<<__LINE__<<"]"<<" Handle Returned: "<<handle<<std::endl;
    assert(handle == 2);

    std::this_thread::sleep_for(std::chrono::seconds(3));

    resourceList = new SysResource[1];
    resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 701;

    handle = tuneResources(2000, 0, 1, resourceList);

    std::cout<<"["<<__LINE__<<"]"<<" Handle Returned: "<<handle<<std::endl;
    assert(handle == 3);

    LOG_END
}

/*
* =========================================================
*   TEST CATEGORY - I: "Resource Tuner REQUEST-VERIFICATION"
* =========================================================
*/

namespace ResourceTuningRequestVerification {
   /*
    * Description:
    * This Section contains tests which aim to verify the correctness of the Verifier.
    * The Verifier is responsible for validating the Tune Request on various param before
    * handing it to the RequestQueue for application. Specifically it checks the following params:
    * - Request Level Tests
    *   - Sanity Tests
    *       - Request should have a positive duration (with the exception of -1) [A]
    *       - Request should specify a non-zero number of Resources to Tune [B]
    *       - Request should have a valid Priority i.e. either HIGH (0) or LOW (1) [D]
    * - Resource Level Tests
    *   - Verifier will iterate over all the Resources part of the Request, and perform the following
    *     tests on each of them. Note if any test fails for any (even one) Resource part of the Request,
    *     then the entire Request shall be dropped.
    *   - Sanity Tests
    *       - Each Resource with the specified ID should exist in the Resource Registry [E]
    *   - Application Tests
    *       - The configured value for the Resource should be in the Range LT, HT as specified by the
    *         Resource Config [F]
    *       - If the Resource has a core level conflict, then Logical to Physical Mapping happens
    *         as part of the Verifier, if the translation cannot be performed then the Request is dropped. [G]
    *       - If the Resource does not support tuning, then the Request will be dropped. [H]
    *       - Check if the Resorce can be tuned in the current System mode. Note, each Resource can specify
    *         via Config, the list of Modes (for example: Display On, Doze) it can be tuned in. [I]
    *   - Permission Check:
    *       - Each Resource can specify a permission level, i.e. only the client with Permission level equal
    *         to or greater than what is specified in the Resource Config can tune that Resource. [J]
    * All the above mentioned cases are covered by the different tests under this section.
    * Note: While almost all the Request Verification happens on the Server end, however to save Server
    * Request Processing time, some very basic Request Verification happens on the Client side as well.
    * This includes testing for cases A, B and C.
    */

    std::string __testGroupName = "Resource Tuner Requests Verification / Integrity Checks";
    /**
    * API under test: Tune
    * - The client tries to send a Request with a duration of 0.
    * - The Request will fail
    *   preliminary tests on the Client side and won't be submitted to the Server,
    *   returning -1 to the End-Client.
    * Cross-Reference id: [A]
    */
    static void TestNullOrInvalidRequestVerification1() {
        LOG_START

        int64_t handle = tuneResources(0, RequestPriority::REQ_PRIORITY_HIGH, 0, nullptr);
        assert(handle == RC_REQ_SUBMISSION_FAILURE);

        LOG_END
    }

    /**
    * API under test: Tune
    * - Resources List should be non-empty for the Request to be considered valid.
    * - Each of the Resource, part of this list should be non-null and valid as well.
    * - Here, a null Resources List is passed to the Tune API, the Request will fail
    *   preliminary tests on the Client side and won't be submitted to the Server,
    *   returning -1 to the End-Client.
    * Cross-Reference id: [B]
    */
    static void TestNullOrInvalidRequestVerification2() {
        LOG_START

        int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 0, nullptr);
        assert(handle == RC_REQ_SUBMISSION_FAILURE);

        LOG_END
    }

    /**
    * API under test: Tune
    * - Resources List should be non-empty for the Request to be considered valid.
    * - Each of the Resource, part of this list should be non-null and valid as well.
    * - Here a non-null Resources List is passed to the Tune API, however the only Resource part of
    *   the Request is invalid, hence the Request will fail the preliminary tests on the Client side
    *   and won't be submitted to the Server, returning -1 to the End-Client.
    * - For checking Resource validity, we check basic SysResource params like mResCode, mResInfo and verify
        that these values are sane.
    * Cross-Reference id: [B]
    */
    static void TestNullOrInvalidRequestVerification3() {
        LOG_START

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = -1;
        resourceList[0].mResInfo = -1;

        int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        assert(handle == RC_REQ_SUBMISSION_FAILURE);

        LOG_END
    }

   /**
    * API under test: Tune
    * - As part of the tune API call, the client specifies a desired priority for the Request,
    *   which is one of the following values:
    *    1. HIGH
    *    2. LOW
    * - If a Client passes a Priority Value other than these Values, then the Request will be dropped.
    * - Verify that the Valid Resource Node's value remains unchanged.
    * Cross-Reference id: [D]
    */
    static void TestClientPriorityAcquisitionVerification() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_min_freq";
        int32_t testResourceOriginalValue = 107;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 554;

        // Invalid Priority Value = 2
        int64_t handle = tuneResources(-1, 2, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

    /**
    * API under test: Tune
    * - A client sends a Resource(s) Provisioning Request to tune a resource for some (possibly inf) duration
    * - The resource in question does not exist in the Resource Registry, i.e. the Client
    * - has specified an invalid Resource ID. The Request should be dropped.
    * - Here we issue a Request with 2 Resources, only one of them is Valid.
    * - Since Verifier checks all the Resource part of the Request, hence when it detects
    *   that one of the Resource does not exist in the Registry, it will drop the Request.
    * - Verify that the Valid Resource Node's value remains unchanged.
    * Cross-Reference id: [E]
    */
    static void TestInvalidResourceTuning() {
        LOG_START

        // Create a list of 2 Resources, where only one of them is valid
        std::string validResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_min_freq";
        int32_t validResourceOriginalValue = 107;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(validResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == validResourceOriginalValue);

        SysResource* resourceList = new SysResource[2];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 554;

        // No Resource with this ID exists
        resourceList[1].mResCode = 12000;
        resourceList[1].mNumValues = 1;
        resourceList[1].mResValue.value = 597;

        int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 2, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(validResourceName);
        newValue = C_STOI(value);
        assert(newValue == validResourceOriginalValue);

        LOG_END
    }

    /**
    * API under test: Tune
    * - A client sends a Resource(s) Provisioning Request to tune a resource for some (possibly inf) duration
    * - The resource in question has a "lower_is_better" policy.
    * - Each Resource has an associated Low Threshold (LT) and High Threshold (HT).
    * - If a client tries to configure a value which is (< LT) or (> HT), then the Reuqest
    *   should be rejected by the Verifier
    * - Verify that the Resource Node's value remains unchanged.
    * Cross-Reference id: [F]
    */
    static void TestOutOfBoundsResourceTuning() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_min_freq";
        int32_t testResourceOriginalValue = 107;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 1200;

        int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

    /**
    * API under test: Tune
    * - As part of the tune API call, the client specifies the target Logical Cluster and Core, if
    *   the resource in question has Core Level Conflict.
    * - For such a Resource (part of the Request), Core / Cluster Logical To Physical Translation is
    *   needed.
    * - If the logical Core / Cluster value is invalid, or if translation cannot be performed then the
    *   Request is dropped.
    * - Here, we setup the values of logical Core and Cluster such that the Translation will fail.
    * - Verify that the Resource Node's value remains unchanged.
    * Cross-Reference id: [G]
    */
    static void TestResourceLogicalToPhysicalTranslationVerification1() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/target_test_resource2";
        int32_t testResourceOriginalValue = 333;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 5);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 2300;
        resourceList[0].mResInfo = 0;
        resourceList[0].mResInfo = SET_RESOURCE_CLUSTER_VALUE(resourceList[0].mResInfo, 2);
        resourceList[0].mResInfo = SET_RESOURCE_CORE_VALUE(resourceList[0].mResInfo, 27);

        int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

    /**
    * API under test: Tune
    * - As part of the tune API call, the client specifies the target Logical Cluster and Core, if
    *   the resource in question has Core Level Conflict.
    * - For such a Resource (part of the Request), Core / Cluster Logical To Physical Translation is
    *   needed.
    * - If the logical Core / Cluster value is invalid, or if translation cannot be performed then the
    *   Request is dropped.
    * - Here, we setup the values of logical Core and Cluster such that the Translation will fail.
    * - Verify that the Resource Node's value remains unchanged.
    * Cross-Reference id: [G]
    */
    static void TestResourceLogicalToPhysicalTranslationVerification2() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/target_test_resource2";
        int32_t testResourceOriginalValue = 333;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[2];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 5);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 2300;
        resourceList[0].mResInfo = 0;
        resourceList[0].mResInfo = SET_RESOURCE_CLUSTER_VALUE(resourceList[0].mResInfo, 5);
        resourceList[0].mResInfo = SET_RESOURCE_CORE_VALUE(resourceList[0].mResInfo, 2);
        int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

    /**
    * API under test: Tune
    * - As part of the tune API call, the client specifies the target Logical Cluster and Core, if
    *   the resource in question has Core Level Conflict.
    * - For such a Resource (part of the Request), Core / Cluster Logical To Physical Translation is
    *   needed.
    * - If the logical Core / Cluster value is invalid, or if translation cannot be performed then the
    *   Request is dropped.
    * - Here, we setup the values of logical Core and Cluster such that the Translation will succeed.
    * - Verify that the Resource Node's changes to the desired value.
    * - Verify that once the Request Expires, the Resource Node value is reset.
    * Cross-Reference id: [G]
    */
    static void TestResourceLogicalToPhysicalTranslationVerification3() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/target_test_resource2";
        int32_t testResourceOriginalValue = 333;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 5);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 2300;
        resourceList[0].mResInfo = 0;
        resourceList[0].mResInfo = SET_RESOURCE_CLUSTER_VALUE(resourceList[0].mResInfo, 2);
        resourceList[0].mResInfo = SET_RESOURCE_CORE_VALUE(resourceList[0].mResInfo, 2);

        int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 2300);

        std::this_thread::sleep_for(std::chrono::seconds(5));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

    /**
    * API under test: Tune
    * - As part of the tune API call, the client specifies the target Logical Cluster and Core, if
    *   the resource in question has Core Level Conflict.
    * - For such a Resource (part of the Request), Core / Cluster Logical To Physical Translation is
    *   needed.
    * - If the logical Core / Cluster value is invalid, or if translation cannot be performed then the
    *   Request is dropped.
    * - Here, we setup the values of logical Core and Cluster such that the Translation will fail.
    * - Verify that the Resource Node's value remains unchanged.
    * Cross-Reference id: [G]
    */
    static void TestResourceLogicalToPhysicalTranslationVerification4() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/target_test_resource2";
        int32_t testResourceOriginalValue = 333;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 5);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 2300;
        resourceList[0].mResInfo = 0;
        resourceList[0].mResInfo = SET_RESOURCE_CLUSTER_VALUE(resourceList[0].mResInfo, 1);
        resourceList[0].mResInfo = SET_RESOURCE_CORE_VALUE(resourceList[0].mResInfo, 0);

        int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

    /**
    * API under test: Tune
    * - As part of the Config, a Resource can specify a "supported" bit, which indicates
    *   If Tuning is allowed for that Resource
    * - If a Request tries to tune a Resource with the supported bit set to false, then the
    * - the Request should be dropped.
    * - Verify that the Resource Node's value remains unchanged.
    * Cross-Reference id: [H]
    */
    static void TestNonSupportedResourceTuningVerification() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/target_test_resource4";
        int32_t testResourceOriginalValue = 516;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 7);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 653;

        int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

    /**
    * API under test: Tune
    * - The Client issues a Tune Request for a Resource which supports Processing in Display Off mode only
    * - However, the current System mode is Display On. In this case, the Configured value for the Resource
    * - as part of the API call should not take effect on the Sysfs Node.
    * - Verify that the Resource Node's value remains unchanged.
    *  Cross-Reference id: [I]
    */
    static void TestResourceOperationModeVerification() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/target_test_resource3";
        int32_t testResourceOriginalValue = 4400;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 6);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 4670;

        int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

    /**
    * API under test: Tune
    * - A client sends a Resource(s) Provisioning Request to tune a resource for some (possibly inf) duration
    * - The resource in question has a "higher_is_better" policy.
    * - Each Resource has an associated permission, either system or third_party. Here the
    *   resource in question has system Permissions i.e. only Clients having system permissions
    *   can tune the resource.
    * - The client here only has third_party permissions, hence the request should be rejected
    *   by the Verifier
    * - Verify that the Resource Node's value remains unchanged.
    * Cross-Reference id: [J]
    */
    static void TestClientPermissionChecksVerification() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/target_test_resource1";
        int32_t testResourceOriginalValue = 240;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 4);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 460;

        int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

    static void RunTestGroup() {
        std::cout<<"\nRunning tests from the Group: "<<__testGroupName<<std::endl;

        RUN_TEST(TestNullOrInvalidRequestVerification1)
        RUN_TEST(TestNullOrInvalidRequestVerification2)
        RUN_TEST(TestNullOrInvalidRequestVerification3)
        RUN_TEST(TestClientPriorityAcquisitionVerification)
        RUN_TEST(TestInvalidResourceTuning)
        RUN_TEST(TestOutOfBoundsResourceTuning)
        RUN_TEST(TestResourceLogicalToPhysicalTranslationVerification1)
        RUN_TEST(TestResourceLogicalToPhysicalTranslationVerification2)
        RUN_TEST(TestResourceLogicalToPhysicalTranslationVerification3)
        RUN_TEST(TestResourceLogicalToPhysicalTranslationVerification4)
        RUN_TEST(TestNonSupportedResourceTuningVerification)
        RUN_TEST(TestResourceOperationModeVerification)
        RUN_TEST(TestClientPermissionChecksVerification)

        std::cout<<"\n\nAll tests from the Group: "<<__testGroupName<<", Ran Successfully"<<std::endl;
    }
}

/*
* =========================================================
*   TEST CATEGORY - II: "SYSSIGNAL REQUEST-VERIFICATION"
* =========================================================
*/

namespace SignalVerification {
   /*
    * Description:
    * This Section contains tests which aim to verify the correctness of the Signal Verifier.
    * The Signal Verifier works similarly to the Resource Tuner Verifier, and performs the following checks:
    *   - Sanity Tests
    *       - Signal Request should have a positive duration (with the exception of -1) [A]
    *   - Priority Level Checking
    *       - As part of tuneSignal API call the Client can specify a desired level of priority
    *         for the Request, if the Client has System level of Permissions then it can assume any
    *         priority it wants, However in case of a third_party Client it can only assume a priority
    *         of either RequestPriority::REQ_PRIORITY_HIGH or RequestPriority::REQ_PRIORITY_LOW. Any violation of the above rule will result
    *         in the Request being dropped. [B]
    *   - Permission Check:
    *       - Each Signal Config can specify a permission level, i.e. only the clients with Permission level equal
    *         to or greater than what is specified in the Signal Config can provision that Signal. [C]
    *   - Resource Level Tests: Verifier will iterate over all the Resources part of the Request, and perform Verification
    *     tests on each of them (As discussed before for Resource Tuner Request Verifier). Note if any test fails for any (even one) Resource part of the Signal,
    *     then the entire Request shall be dropped. [D]
    *   - Target Compatability Tests: Checks if the signal is eligible for provisioning on the given Target. [E]
    *   - Application Tests:
    *       - The Specified signal should be Enabled for Provisioning [F]
    * All the above mentioned cases are covered by the different tests under this section.
    */

    std::string __testGroupName = "Signal Requests Verification / Integrity Checks";
    /**
    * API under test: tuneSignal
    * - The client tries to tune a Signal with a duration of -2.
    * - Note a duration of 0 is considered valid for the tuneSignal API.
    * - The Request will fail reliminary tests on the Client side and won't be
    *   submitted to the Server returning -1 to the End-Client.
    * Cross-Reference id: [A]
    */
    static void TestNullOrInvalidRequestVerification() {
        LOG_START

        int64_t handle = tuneSignal(1, -2, RequestPriority::REQ_PRIORITY_HIGH, "app-name", "scenario-zip", 0, nullptr);
        assert(handle == RC_REQ_SUBMISSION_FAILURE);

        LOG_END
    }

    /**
    * API under test: tuneSignal
    * - A client sends a Signal Request to tune a Signal for some (possibly inf) duration
    * - Each Signal Config has an associated permission, either system or third_party. Here the
    *   Signal in question has system Permissions i.e. only Clients having system permissions
    *   can tune this signal.
    * - The client here only has third_party permissions, hence the request should be rejected
    *   by the Signal Verifier
    * - Verify that the Resource Node's value remains unchanged.
    * Cross-Reference id: [C]
    */
    static void TestClientPermissionChecksVerification() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/sched_util_clamp_max";
        int32_t testResourceOriginalValue = 684;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        int64_t handle =
            tuneSignal(0x800d0001, 5000, RequestPriority::REQ_PRIORITY_HIGH, "app-name", "scenario-zip", 0, nullptr);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

    /**
    * API under test: tuneSignal
    * - A client sends a Signal Request to Tune a Signal for some (possibly inf) duration
    * - Each Resource associated with the Signal Config has an associated Low Threshold (LT) and High Threshold (HT).
    * - If a Signal Config specifies a value which is (< LT) or (> HT) for any Resource, then the Reuqest
    *   should be rejected by the Signal Verifier
    * - Verify that the Resource Node's value remains unchanged.
    * Cross-Reference id: [D]
    */
    static void TestOutOfBoundsResourceTuning() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/sched_util_clamp_min";
        int32_t testResourceOriginalValue = 300;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        int64_t handle =
            tuneSignal(0x800d0002, 5000, RequestPriority::REQ_PRIORITY_HIGH, "app-name", "scenario-zip", 0, nullptr);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

    /**
    * API under test: tuneSignal
    * - Through the Signal Configs, it can be specified for each Signal which target it is supported
    *   on and for which it is not eligible for provisioning.
    * - If a client tries to tune a Signal on a Target, where the Signal is not supported, the
    *   request should be rejected by the Signal Verifier.
    * - Verify that the Resource Node's value remains unchanged.
    * - Here the Signal in question is supported on "sun" and "moon", but the client tries to tune it
    *   on Kodiak. Hence, the Request should be dropped.
    * Cross-Reference id: [E]
    */
    static void TestTargetCompatabilityVerificationChecks() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/sched_util_clamp_min";
        int32_t testResourceOriginalValue = 300;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        int64_t handle =
            tuneSignal(0x800d0000, 5000, RequestPriority::REQ_PRIORITY_HIGH, "app-name", "scenario-zip", 0, nullptr);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

    /**
    * API under test: tuneSignal
    * - If the Enabled Field for the Signal Config is set to false, the Signal should not be provisioned.
    * - Hence, the Request is rejected by the Signal Verifier.
    * - Verify that the Resource Node's value remains unchanged.
    * Cross-Reference id: [F]
    */
    static void TestNonSupportedSignalProvisioningVerification() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/sched_util_clamp_min";
        int32_t testResourceOriginalValue = 300;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        int64_t handle =
            tuneSignal(0x800d0003, 5000, RequestPriority::REQ_PRIORITY_HIGH, "app-name", "scenario-zip", 0, nullptr);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

    static void RunTestGroup() {
        std::cout<<"\nRunning tests from the Group: "<<__testGroupName<<std::endl;

        RUN_TEST(TestNullOrInvalidRequestVerification)
        RUN_TEST(TestClientPermissionChecksVerification)
        RUN_TEST(TestOutOfBoundsResourceTuning)
        RUN_TEST(TestTargetCompatabilityVerificationChecks)
        RUN_TEST(TestNonSupportedSignalProvisioningVerification)

        std::cout<<"\n\nAll tests from the Group: "<<__testGroupName<<", Ran Successfully"<<std::endl;
    }
}

/*
* =========================================================
*   TEST CATEGORY - III: "REQUEST-APPLICATION"
* =========================================================
*/

namespace RequestApplicationTests {
   /*
    * Description:
    * This Section contains tests which aim to verify the correctness of Request Application.
    * Here the components majorly involved are RequestQueue and CocoTable.
    * The value of the resource Node is updated based on it's policy.
    * The tests in this section aim to verify that the Resource Nodes are updated
    * correctly in accordace with the Policy, in the case of Concurrent Requests for the same Resource.
    * The tests are enumerated as follows:
    * => Single Client - Single Resource Tuning [A]
    * => Single Client - Multiple Resources Tuning [B]
    * => Multiple Clients - Single Resource Tuning
    *   -- Policy: Higher Is Better [C]
    *   -- Polciy: Lower is Better [D]
    *   -- Policy: Lazy Apply [E]
    *   -- Instant Apply [F]
    * => Multiple Clients - Multiple Resources [G]
    * Special Cases:
    *   => Single Client, Multiple Sequential Requests [S1]
    *   => Multiple Client TIDs, Concurrent Requests [S2]
    * Untune Requests Handling
    * => Valid Untuning: Client C1 issued Request H1, and C1 issues an untune for H1 [U1]
    * => Invalid Untuning: Client C1 issue Request H1, however another client C2 tries
    *    to issue an untune for H2 [U2]
    * Priority Acquisition:
    * => Ensure that a Request with higher Priority always takes effect over another
    *    Request trying to provision the same resource, but with a lower Priority. [H]
    * Retune Requests Handling:
    * => Valid Retuning: Client C1 issued Request H1, and C1 issues a Retune for H1 [R1]
    * => Invalid Retuning:
    * - Client tries to reduce Request Duration [R2]
    * - Client C1 issues Request H1, however another client C2 tries to Retune H1 [R3]
    */

    std::string __testGroupName = "Request Application Checks";

    /**
    * API under test: Tune / Untune
    * - Try to configure the value for a specific resource Node.
    * - Here we have a single client, hence no concurrency considerations.
    * - Verify that the config takes effect.
    * - Verify that once the Request Expires, the Resource Node value is reset.
    * Cross-Reference id: [A]
    */
    static void TestSingleClientTuneRequest() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/sched_util_clamp_min";
        int32_t testResourceOriginalValue = 300;

        // Check the original value for the Resource
        std::string value = AuxRoutines::readFromFile(testResourceName);
        int32_t originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 0);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 980;

        int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(1));

        // Check if the new value was successfully written to the node
        value = AuxRoutines::readFromFile(testResourceName);
        int32_t newValue = C_STOI(value);
        assert(newValue == 980);

        std::this_thread::sleep_for(std::chrono::seconds(6));

        // Wait for the Request to expire, check if the value resets
        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == originalValue);

        LOG_END
    }

    /**
    * API under test: Tune / Untune
    * - Single Client sends a request to tune multiple resources (3 here).
    * - Here we have a single client, hence no concurrency considerations.
    * - Verify that the supplied valued takes effect on each of the resource nodes.
    * - Verify that once the Request Expires, each of the Resource Node value is reset.
    * Cross-Reference id: [B]
    */
    static void TestSingleClientTuneRequestMultipleResources() {
        LOG_START

        // Check the original value for each of the Resource
        std::string testResourceName1 = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_max_freq";
        std::string testResourceName2 = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_min_freq";
        std::string testResourceName3 = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/sched_util_clamp_max";

        int32_t testResourceOriginalValue1 = 114;
        int32_t testResourceOriginalValue2 = 107;
        int32_t testResourceOriginalValue3 = 684;

        std::string value;
        int32_t originalValue[3], newValue;

        value = AuxRoutines::readFromFile(testResourceName1);
        originalValue[0] = C_STOI(value);
        assert(originalValue[0] == testResourceOriginalValue1);

        value = AuxRoutines::readFromFile(testResourceName2);
        originalValue[1] = C_STOI(value);
        assert(originalValue[1] == testResourceOriginalValue2);

        value = AuxRoutines::readFromFile(testResourceName3);
        originalValue[2] = C_STOI(value);
        assert(originalValue[2] == testResourceOriginalValue3);

        SysResource* resourceList = new SysResource[3];

        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 3);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 765;

        resourceList[1].mResCode = GENERATE_RESOURCE_ID(1, 1);
        resourceList[1].mNumValues = 1;
        resourceList[1].mResValue.value = 889;

        resourceList[2].mResCode = GENERATE_RESOURCE_ID(1, 2);
        resourceList[2].mNumValues = 1;
        resourceList[2].mResValue.value = 617;

        int64_t handle = tuneResources(6000, RequestPriority::REQ_PRIORITY_HIGH, 3, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(1));

        // Check if the new value was successfully written to each of the nodes
        value = AuxRoutines::readFromFile(testResourceName1);
        newValue = C_STOI(value);
        assert(newValue == 765);

        value = AuxRoutines::readFromFile(testResourceName2);
        newValue = C_STOI(value);
        assert(newValue == 617);

        value = AuxRoutines::readFromFile(testResourceName3);
        newValue = C_STOI(value);
        assert(newValue == 889);

        std::this_thread::sleep_for(std::chrono::seconds(6));

        // Wait for the Request to expire, check if the values reset
        value = AuxRoutines::readFromFile(testResourceName1);
        newValue = C_STOI(value);
        assert(newValue == originalValue[0]);

        value = AuxRoutines::readFromFile(testResourceName2);
        newValue = C_STOI(value);
        assert(newValue == originalValue[1]);

        value = AuxRoutines::readFromFile(testResourceName3);
        newValue = C_STOI(value);
        assert(newValue == originalValue[2]);

        std::this_thread::sleep_for(std::chrono::seconds(4));

        LOG_END
    }

    /**
    * API under test: Tune / Untune
    * - Two clients send requests for the same resource concurrently.
    * - Verify that the correct values takes effect for the Resource Node.
    * - Here the resource in question has the "Higher-Is-Better" policy, hence the bigger value of
    *   the 2 should take effect.
    * - Verify that once both the Request Expires (Note: Here both the requests have exactly the same duration), the
    *   Resource Node value should be reset.
    * Cross-Reference id: [C]
    */
    static void TestMultipleClientsHigherIsBetterPolicy1() {
        LOG_START

        // Check the original value for the Resource
        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_max_freq";
        int32_t testResourceOriginalValue = 114;

        std::string value = AuxRoutines::readFromFile(testResourceName);
        int32_t originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        int32_t rc = fork();
        if(rc == 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 3);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 315;

            int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
            exit(EXIT_SUCCESS);

        } else if(rc > 0) {
            wait(nullptr);

            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 3);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 209;

            int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            std::this_thread::sleep_for(std::chrono::seconds(2));

            // Check if the new value was successfully written to the node
            value = AuxRoutines::readFromFile(testResourceName);
            int32_t newValue = C_STOI(value);

            // Note value should be the higher of the 2, since for this resource the
            // policy set is "Higher is Better"
            assert(newValue == 315);

            std::this_thread::sleep_for(std::chrono::seconds(8));

            // Wait for the Request to expire, check if the value resets
            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == originalValue);
        }

        LOG_END
    }

    /**
    * API under test: Tune / Untune
    * - Two clients send requests for Provisioning the same resource concurrently, with different durations
    * - Req1: duration: d1, value: v1
    * - Req2: duration: d2, value: v2
    * - Here the resource in question has the "Higher-Is-Better" policy, hence the bigger value should always take effect
    *   on the node in case of conflicts.
    * - Here d2 > d1 and v1 > v2, both requests are issued concurrently by different processes.
    * - Verify that the correct value takes effect for the Resource Node at different points in time.
    * - From time ~0 to d1, the value v1 (since v1 > v2) should be written to the node, however from time d1 to d2, the value v2 should be written to the node.
    * - Verify that once both the Request Expires (Note: Here both the requests don't have the same duration), the
    *   Resource Node value is reset.
    * Cross-Reference id: [C]
    */
    static void TestMultipleClientsHigherIsBetterPolicy2() {
        LOG_START

        // Check the original value for the Resource
        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_max_freq";
        int32_t testResourceOriginalValue = 114;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        int32_t rc1 = fork();
        if(rc1 == 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 3);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 1176;

            int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            exit(EXIT_SUCCESS);

        } else if(rc1 > 0) {
            wait(nullptr);
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 3);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 823;

            int64_t handle = tuneResources(14000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            std::this_thread::sleep_for(std::chrono::seconds(2));

            // Check if the new value was successfully written to the node
            // The higher value should be written to the node, since the Resource has
            // Higer is better policy
            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == 1176);

            std::this_thread::sleep_for(std::chrono::seconds(6));

            // By this time the Request configuring the value of 1176 should have expired
            // And the Pending Request with a configuration value of 823, should take effect.
            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == 823);

            std::this_thread::sleep_for(std::chrono::seconds(10));

            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == originalValue);
        }

        LOG_END
    }

    /**
    * API under test: Tune / Untune
    * - Four clients send requests for the same resource concurrently, with the same durations
    * - Req1: duration: d1, value: v1
    * - Req2: duration: d2, value: v2
    *   and similary for other Requests.
    * - d1 = d2 = d3 = d4.
    * - v1 > v2 > v3 > v4
    * - Here the resource in question has the "Lower-Is-Better" policy, hence the smaller value should always take effect
    *   on the node in case of conflicts.
    * - Verify that the correct value takes effect for the Resource Node at different points in time.
    * - Verify that once all the Requests Expires (Note: Here all the requests have exactly the same duration), the
    *   Resource Node value is reset.
    * Cross-Reference id: [D]
    */
    static void TestMultipleClientsLowerIsBetterPolicy() {
        LOG_START

        // Check the original value for the Resource
        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_min_freq";
        int32_t testResourceOriginalValue = 107;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        int64_t handle;

        int32_t rc1 = fork();
        if(rc1 == 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 578;

            handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            exit(EXIT_SUCCESS);

        } else if(rc1 > 0) {
            wait(nullptr);
            std::this_thread::sleep_for(std::chrono::seconds(1));

            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == 578);

            int32_t rc2 = fork();
            if(rc2 == 0) {
                SysResource* resourceList = new SysResource[1];
                resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
                resourceList[0].mNumValues = 1;
                resourceList[0].mResValue.value = 445;

                handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

                exit(EXIT_SUCCESS);

            } else if(rc2 > 0) {
                wait(nullptr);
                std::this_thread::sleep_for(std::chrono::seconds(1));

                value = AuxRoutines::readFromFile(testResourceName);
                newValue = C_STOI(value);
                assert(newValue == 445);

                int32_t rc3 = fork();
                if(rc3 == 0) {
                    SysResource* resourceList = new SysResource[1];
                    resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
                    resourceList[0].mNumValues = 1;
                    resourceList[0].mResValue.value = 412;

                    handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

                    exit(EXIT_SUCCESS);

                } else if(rc3 > 0) {
                    wait(nullptr);
                    std::this_thread::sleep_for(std::chrono::seconds(1));

                    value = AuxRoutines::readFromFile(testResourceName);
                    newValue = C_STOI(value);
                    assert(newValue == 412);

                    SysResource* resourceList = new SysResource[1];
                    resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
                    resourceList[0].mNumValues = 1;
                    resourceList[0].mResValue.value = 378;

                    handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

                    std::this_thread::sleep_for(std::chrono::seconds(1));

                    value = AuxRoutines::readFromFile(testResourceName);
                    newValue = C_STOI(value);
                    assert(newValue == 378);

                    std::this_thread::sleep_for(std::chrono::seconds(8));

                    value = AuxRoutines::readFromFile(testResourceName);
                    newValue = C_STOI(value);
                    assert(newValue == originalValue);
                }
            }
        }

        LOG_END
    }

    /**
    * API under test: Tune / Untune
    * - Two clients send requests for the same resource concurrently, with different durations
    * - Req1: duration: d1, value: v1
    * - Req2: duration: d2, value: v2
    * - Here the resource in question has the "Lazy-Apply" policy, hence the Request should take
    * - effect in a "First-In First-Out (FIFO)" manner.
    * - Verify that the correct value takes effect for the Resource Node at different points in time.
    * - Verify that once all the Requests Expires, the Resource Node value is reset.
    * Cross-Reference id: ['E']
    */
    static void TestMultipleClientsLazyApplyPolicy() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/target_test_resource5";
        int32_t testResourceOriginalValue = 17;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        int64_t handle;
        int32_t rc1 = fork();
        if(rc1 == 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 8);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 15;

            handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            exit(EXIT_SUCCESS);

        } else if(rc1 > 0) {
            wait(nullptr);
            std::this_thread::sleep_for(std::chrono::seconds(1));

            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 8);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 18;

            handle = tuneResources(15000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            std::this_thread::sleep_for(std::chrono::seconds(1));

            // The new Value should be valid for 8 seconds
            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == 15);

            std::this_thread::sleep_for(std::chrono::seconds(3));
            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == 15);

            std::this_thread::sleep_for(std::chrono::seconds(8));
            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == 18);

            std::this_thread::sleep_for(std::chrono::seconds(10));

            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == originalValue);
        }

        LOG_END
    }

    /**
    * API under test: Tune / Untune
    * - Three clients send requests for three different resources concurrently, with the same duration
    * - Here the Requests are for separate resources, hence no concurrency considerations at Resource Level
    * - Verify that the supplied value takes effect for each of the Resource Nodes (Note, all the Requests are designed to be valid).
    * - Verify that each of the request expires, the corresponding Resource Node's value is reset
    * - Cross-Reference id: ['G']
    */
    static void TestMultipleClientsTuneRequestDifferentResources() {
        LOG_START

        // Check the original value for the Resource
        std::string testResourceName1 = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_min_freq";
        std::string testResourceName2 = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_max_freq";
        std::string testResourceName3 = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/sched_util_clamp_max";

        int32_t testResourceOriginalValue1 = 107;
        int32_t testResourceOriginalValue2 = 114;
        int32_t testResourceOriginalValue3 = 684;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName1);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue1);

        value = AuxRoutines::readFromFile(testResourceName2);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue2);

        value = AuxRoutines::readFromFile(testResourceName3);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue3);

        int32_t rc1 = fork();
        if(rc1 == 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 717;

            int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            exit(EXIT_SUCCESS);

        } else if(rc1 > 0) {
            int32_t rc2 = fork();
            if(rc2 == 0) {
                SysResource* resourceList = new SysResource[1];
                resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 3);
                resourceList[0].mNumValues = 1;
                resourceList[0].mResValue.value = 800;

                int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

                exit(EXIT_SUCCESS);

            } else if(rc2 > 0) {
                SysResource* resourceList = new SysResource[1];
                resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 1);
                resourceList[0].mNumValues = 1;
                resourceList[0].mResValue.value = 557;

                int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

                std::this_thread::sleep_for(std::chrono::seconds(4));

                // Check if the new value was successfully written to the node
                value = AuxRoutines::readFromFile(testResourceName1);
                newValue = C_STOI(value);
                assert(newValue == 717);

                value = AuxRoutines::readFromFile(testResourceName2);
                newValue = C_STOI(value);
                assert(newValue == 800);

                value = AuxRoutines::readFromFile(testResourceName3);
                newValue = C_STOI(value);
                assert(newValue == 557);

                // Wait for the Nodes to Reset
                std::this_thread::sleep_for(std::chrono::seconds(10));

                value = AuxRoutines::readFromFile(testResourceName1);
                originalValue = C_STOI(value);
                assert(originalValue == testResourceOriginalValue1);

                value = AuxRoutines::readFromFile(testResourceName2);
                originalValue = C_STOI(value);
                assert(originalValue == testResourceOriginalValue2);

                value = AuxRoutines::readFromFile(testResourceName3);
                originalValue = C_STOI(value);
                assert(originalValue == testResourceOriginalValue3);

                waitpid(rc1, nullptr, 0);
                waitpid(rc2, nullptr, 0);
            }
        }

        LOG_END
    }

    /**
    * API under test: Tune / Untune
    * - Single Client sends multiple requests sequentially to tune the same resource.
    * - The resource in question has a "high_is_better" policy.
    * - Verify that the higher of the two supplied valued takes effect on the resource node.
    * - Verify that once the Request Expires, the Resource Node's value is reset.
    * Cross-Reference id: ['S1']
    */
    static void TestSingleClientSequentialRequests() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_max_freq";
        int32_t testResourceOriginalValue = 114;
        int64_t handle;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList1 = new SysResource[1];
        resourceList1[0].mResCode = GENERATE_RESOURCE_ID(1, 3);
        resourceList1[0].mNumValues = 1;
        resourceList1[0].mResValue.value = 889;

        SysResource* resourceList2 = new SysResource[1];
        resourceList2[0].mResCode = GENERATE_RESOURCE_ID(1, 3);
        resourceList2[0].mNumValues = 1;
        resourceList2[0].mResValue.value = 917;

        handle = tuneResources(6000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList1);
        handle = tuneResources(6000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList2);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 917);

        std::this_thread::sleep_for(std::chrono::seconds(6));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

    /**
    * API under test: Tune / Untune
    * - Two threads of the same Client process send requests concurrently to tune the same resource.
    * - The resource in question has a "high_is_better" policy.
    * - Verify that the higher of the two supplied valued takes effect on the resource node.
    * - Verify that once the Request Expires, the Resource Node's value is reset.
    * - Note, only a single thread can send a message over the Socket at once, the other thread will
    * - be blocked until the first thread is done.
    * Cross-Reference id: ['S2']
    */
    static void TestMultipleClientTIDsConcurrentRequests() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_max_freq";
        int32_t testResourceOriginalValue = 114;
        int64_t handle;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        std::thread th([&]{
            SysResource* resourceList1 = new SysResource[1];
            resourceList1[0].mResCode = GENERATE_RESOURCE_ID(1, 3);
            resourceList1[0].mOptionalInfo = 0;
            resourceList1[0].mNumValues = 1;
            resourceList1[0].mResValue.value = 664;

            handle = tuneResources(6000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList1);
        });

        SysResource* resourceList2 = new SysResource[1];
        resourceList2[0].mResCode = GENERATE_RESOURCE_ID(1, 3);
        resourceList2[0].mOptionalInfo = 0;
        resourceList2[0].mNumValues = 1;
        resourceList2[0].mResValue.value = 702;

        handle = tuneResources(6000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList2);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 702);

        std::this_thread::sleep_for(std::chrono::seconds(6));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        th.join();

        LOG_END
    }

    /**
    * API under test: Tune / Untune
    * - A client sends a Resource(s) Provisioning Request to tune a resource for an infinite (-1) duration
    * - The resource in question has a "lower_is_better" policy.
    * - Verify that the supplied valued takes effect on the resource node.
    * - Send an untune request from the client.
    * - Verify that the Resource Node's value is reset.
    * - Note only the client which issued the Tune request can issue a corresponding Untune
    *   Request for the same Handle.
    * Cross-Reference id: ['U1']
    */
    static void TestInfiniteDurationTuneRequestAndValidUntuning() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_min_freq";
        int32_t testResourceOriginalValue = 107;
        int64_t handle;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 245;
        handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 245);

        untuneResources(handle);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

    /**
    * API under test: Tune / Untune
    * - A client (X) sends a Resource(s) Provisioning Request to tune a resource for an infinite (-1) duration
    * - The resource in question has a "lower_is_better" policy.
    * - Verify that the supplied valued takes effect on the resource node.
    * - Send an untune request from another client (Y).
    * - Verify that the Resource Node's value is not reset.
    * - Note only the client which issued the Tune request can issue a corresponding Untune
    *   Request for the same Handle.
    * - Now send an Untune request from Client X, and verify that the Resource Node's value
    *   is indeed reset.
    * Cross-Reference id: ['U2']
    */
    static void TestInfiniteDurationTuneRequestAndInValidUntuning() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_min_freq";
        int32_t testResourceOriginalValue = 107;
        int64_t handle;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 245;

        handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 245);

        int32_t rc = fork();
        if(rc == 0) {
            // Child Process
            untuneResources(handle);

            exit(EXIT_SUCCESS);

        } else if(rc > 0) {
            wait(nullptr);

            std::this_thread::sleep_for(std::chrono::seconds(2));

            // Verify that there is no change in value
            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == 245);

            untuneResources(handle);

            std::this_thread::sleep_for(std::chrono::seconds(2));

            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == testResourceOriginalValue);
        }

        LOG_END
    }

    /**
    * API under test: Tune / Untune
    * - The CocoTable structure is built to handle 4 levels of Priority. A request with
    *   higher priority should take precedence over another with lower priority.
    * - This notion should reflect with respect to Resource Tuning as well, i.e. if there
    *   are 2 valid Requests:
    *   R1, with Priority P1 trying to configure a value of V1 for Resource X
    *   R2, with Priority P2 trying to configure a value of V2 for Resource X
    *   Where, P1 > P1, then the value V1 should take effect on the Resource Sysfs Node
    *   rather than the value V2.
    * - In this case both Requests are sent by the same Client
    * - Verify that the Correct Value takes affect on the Sysfs Nodes
    * - Verify that the Sysfs Node is reset, once the Request Expires
    * Cross-Reference id: ['H']
    */
    static void TestPriorityBasedResourceAcquisition1() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_min_freq";
        int32_t testResourceOriginalValue = 107;
        int64_t handle;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList1 = new SysResource[1];
        resourceList1[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
        resourceList1[0].mNumValues = 1;
        resourceList1[0].mResValue.value = 515;

        handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_LOW, 1, resourceList1);

        SysResource* resourceList2 = new SysResource[1];
        resourceList2[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
        resourceList2[0].mNumValues = 1;
        resourceList2[0].mResValue.value = 559;

        handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList2);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 559);

        std::this_thread::sleep_for(std::chrono::seconds(10));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

    /**
    * API under test: Tune / Untune
    * - The CocoTable structure is built to handle 4 levels of Priority. A request with
    *   higher priority should take precedence over another with lower priority.
    * - This notion should reflect with respect to Resource Tuning as well, i.e. if there
    *   are 2 valid Requests:
    *   R1, with Priority P1 trying to configure a value of V1 for Resource X
    *   R2, with Priority P2 trying to configure a value of V2 for Resource X
    *   Where, P1 > P1, then the value V1 should take effect on the Resource Sysfs Node
    *   rather than the value V2.
    * - The Resource in Question here has a "lower_is_better" policy.
    * - In this case both Requests are sent by the same Client within an interval of 5 seconds
    * - i.e. R2 will be sent at time t and R1 at time t + 5
    * - Verify that the Correct Value takes affect on the Sysfs Nodes, i.e. from time
    *   [t, t + 5) the value on the Node should be V2, following which the value V1 should
    *   take effect (as the Request with Higher Priority will be submitted).
    * - Verify that the Sysfs Node is reset, once the Request Expires.
    * Cross-Reference id: ['H']
    */
    static void TestPriorityBasedResourceAcquisition2() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_min_freq";
        int32_t testResourceOriginalValue = 107;
        int64_t handle;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList1 = new SysResource[1];
        resourceList1[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
        resourceList1[0].mNumValues = 1;
        resourceList1[0].mResValue.value = 515;

        handle = tuneResources(12000, RequestPriority::REQ_PRIORITY_LOW, 1, resourceList1);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 515);

        std::this_thread::sleep_for(std::chrono::seconds(3));

        SysResource* resourceList2 = new SysResource[1];
        resourceList2[0].mResCode = GENERATE_RESOURCE_ID(1, 2);
        resourceList2[0].mNumValues = 1;
        resourceList2[0].mResValue.value = 559;

        handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList2);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 559);

        std::this_thread::sleep_for(std::chrono::seconds(10));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

  /**
    * API under test: Tune / Untune
    * - The CocoTable structure is built to handle 4 levels of Priority. A request with
    *   higher priority should take precedence over another with lower priority.
    * - This notion should reflect with respect to Resource Tuning as well, i.e. if there
    *   are 2 valid Requests:
    *   R1, with Priority P1 trying to configure a value of V1 for Resource X
    *   R2, with Priority P2 trying to configure a value of V2 for Resource X
    *   Where, P1 > P2, and V1 < V2
    * - Here the Resource in Question has a "higher_is_better" policy.
    * - At time t = 0 seconds, Request R1 arrives, since there are no other Requests, it should
        immediately take effect.
    * - At time t = 5 seconds, Request R2 arrives, since V2 > V1, in normal conditions, V2 should
    *   be applied to the Resource Node.
    * - However, since P1 > P2, hence V1 will continue to remain applied ahead of V2.
    * - Verify that the Resource Node is reset once the Requests expire
    * Cross-Reference id: ['H']
    */
    static void TestPriorityBasedResourceAcquisition3() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_max_freq";
        int32_t testResourceOriginalValue = 114;
        int64_t handle;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList1 = new SysResource[1];
        resourceList1[0].mResCode = GENERATE_RESOURCE_ID(1, 3);
        resourceList1[0].mOptionalInfo = 0;
        resourceList1[0].mNumValues = 1;
        resourceList1[0].mResValue.value = 645;

        handle = tuneResources(10000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList1);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 645);

        std::this_thread::sleep_for(std::chrono::seconds(1));

        SysResource* resourceList2 = new SysResource[1];
        resourceList2[0].mResCode = GENERATE_RESOURCE_ID(1, 3);
        resourceList2[0].mNumValues = 1;
        resourceList2[0].mResValue.value = 716;

        handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_LOW, 1, resourceList2);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 645);

        std::this_thread::sleep_for(std::chrono::seconds(10));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

  /**
    * API under test: Retune
    * - Client can use the Retune API to extend the duration of a previously issued Tune Request.
    * - Note only the client which issue the Tune Request with H1, can issue a Retune API for H1.
    * - Here the issues a Tune Request for 8 seconds, however later Retunes it to 15 seconds.
    * - Verify that the Configured values is applied to the Resource Node for this entire duration, i.e. till
    *   15 seconds from the point of issuing the Retune Request.
    * - Note, Retune API only supports extending the duration of a Request and not decreasing it.
    * Cross-Reference id: ['R1']
    */
    static void TestRequestValidRetuning() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_max_freq";
        int32_t testResourceOriginalValue = 114;
        int64_t handle;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 3);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 778;

        handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(4));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 778);

        // Wait for 10 seconds and check the Sysfs Node value
        // The Request will expire in 4 seconds, hence the value should reset to original value
        // However we issue an Untune Request for this handle, and change the duration to 15 seconds
        // Hence when we check the value after 10 seconds, it should still be 778
        retuneResources(handle, 15000);

        std::this_thread::sleep_for(std::chrono::seconds(10));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 778);

        std::this_thread::sleep_for(std::chrono::seconds(10));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

  /**
    * API under test: Retune
    * - Client can use the Retune API to extend the duration of a previously issued Tune Request.
    * - Note only the client which issue the Tune Request with H1, can issue a Retune API for H1.
    * - Retune API only supports extending the duration of a Request and not decreasing it.
    * - Here the Client issues a Tune Request for 12 seconds, and later tries to Retune it to 6 seconds.
    * - Since the Retune API does not support decreasing Request Duration, hence this Retune Request
    *   should be rejected.
    * Cross-Reference id: ['R2']
    */
    static void TestRequestInvalidRetuning1() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_max_freq";
        int32_t testResourceOriginalValue = 114;
        int64_t handle;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 3);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 778;

        handle = tuneResources(12000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 778);

        // This Request should be rejected by the Server, since Request duration cannot be decreased
        retuneResources(handle, 6000);

        std::this_thread::sleep_for(std::chrono::seconds(7));

        // Node value should still be set to the value configured via the Tune Request, as the Retune
        // Request was rejected.
        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 778);

        std::this_thread::sleep_for(std::chrono::seconds(6));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

  /**
    * API under test: Retune
    * - Client can use the Retune API to extend the duration of a previously issued Tune Request.
    * - Note only the client which issue the Tune Request with H1, can issue a Retune API for H1.
    * - Retune API only supports extending the duration of a Request and not decreasing it.
    * - Here the Client issues a Tune Request for 12 seconds, and later tries to Retune it to 6 seconds.
    * - Since the Retune API does not support decreasing Request Duration, hence this Retune Request
    *   should be rejected.
    * Cross-Reference id: ['R3']
    */
    static void TestRequestInvalidRetuning2() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/sched_util_clamp_min";
        int32_t testResourceOriginalValue = 300;

        std::string value;
        int32_t originalValue, newValue;

        int64_t handle;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(1, 0);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 597;

        handle = tuneResources(7000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 597);

        int32_t rc = fork();
        if(rc == 0) {
            // Child Process
            retuneResources(handle, 20000);

            exit(EXIT_SUCCESS);

        } else if(rc > 0) {
            wait(nullptr);

            // Verify that the value has reset after the original Request duration has expired
            std::this_thread::sleep_for(std::chrono::seconds(10));

            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == testResourceOriginalValue);
        }

        LOG_END
    }

    static void RunTestGroup() {
        std::cout<<"\nRunning tests from the Group: "<<__testGroupName<<std::endl;

        RUN_TEST(TestSingleClientTuneRequest);
        RUN_TEST(TestSingleClientTuneRequestMultipleResources)
        RUN_TEST(TestMultipleClientsHigherIsBetterPolicy1)
        RUN_TEST(TestMultipleClientsHigherIsBetterPolicy2)
        RUN_TEST(TestMultipleClientsLowerIsBetterPolicy)
        RUN_TEST(TestMultipleClientsLazyApplyPolicy)
        RUN_TEST(TestMultipleClientsTuneRequestDifferentResources)
        RUN_TEST(TestSingleClientSequentialRequests)
        RUN_TEST(TestMultipleClientTIDsConcurrentRequests)
        RUN_TEST(TestInfiniteDurationTuneRequestAndValidUntuning)
        RUN_TEST(TestInfiniteDurationTuneRequestAndInValidUntuning)
        RUN_TEST(TestPriorityBasedResourceAcquisition1)
        RUN_TEST(TestPriorityBasedResourceAcquisition2)
        RUN_TEST(TestPriorityBasedResourceAcquisition3)
        RUN_TEST(TestRequestValidRetuning)
        RUN_TEST(TestRequestInvalidRetuning1)

        std::cout<<"\n\nAll tests from the Group: "<<__testGroupName<<", Ran Successfully"<<std::endl;
    }
}

namespace SystemSysfsNodesTests {
   /*
    * Description:
    * This Section contains tests which aim to verify that the real System Sysfs NOdes
    * are getting updated correctly by Resource Tuner.
    * Single Client Update / Reset [E1]
    * Concurrent Requests with different Config Values and Same Duration [E2]
    * Concurrent Requests with different Config Values and Differrent Duration [E3]
    * Untune a Resource Tuner Provisioning Request [E4]
    * Concurrent Requests with different Priorities [E5]
    */

    std::string __testGroupName = "System Sysfs Nodes Read / Writes via Resource Tuner Tests";
    /**
    * API under test: Tune / Untune
    * - Issue a Resource Tuner Resource Provisioning Request, to modify the Resource
    *   sched_util_clamp_min
    * - Verify the Resource Node is Correctly updated
    * - Verify that the Resource Node is reset once the Request Expires
    * - Note these Tests need to be run with Root Privleges (sudo)
    * Cross-Reference id: ['E1']
    */
    static void TestWriteTo_sched_util_clamp_min_Node() {
        LOG_START

        std::string testResourceName = "/proc/sys/kernel/sched_util_clamp_min";
        int32_t testResourceOriginalValue = 1024;

        // Check the original value for the Resource
        std::string value = AuxRoutines::readFromFile(testResourceName);
        std::cout<<"["<<__LINE__<<"]"<<" sched_util_clamp_min Original Value: "<<value<<std::endl;
        int32_t originalValue = C_STOI(value);

        if(originalValue == -1) {
            // Node does not exist on test device, can't proceed with this test
            std::cout<<"["<<__LINE__<<"]"<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
            return;
        }

        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(8, 0);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 980;

        int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(1));

        // Check if the new value was successfully written to the node
        value = AuxRoutines::readFromFile(testResourceName);
        int32_t newValue = C_STOI(value);
        assert(newValue == 980);

        std::this_thread::sleep_for(std::chrono::seconds(6));

        // Wait for the Request to expire, check if the value resets
        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == originalValue);

        LOG_END
    }

    /**
    * API under test: Tune / Untune
    * - Issue 2 Concurrent Resource Tuner Resource Provisioning Requests, to modify the Resource
    *   sched_util_clamp_min
    * - Verify the Resource Node is Correctly updated to the higher of the 2 values,
    *   as the Resource has the "higher-is-better" policy.
    * - Verify that the Resource Node is reset once the Requests Expire (here both the Requests,
    *   have exactly the same duration).
    * - Note these Tests need to be run with Root Privleges (sudo)
    * Cross-Reference id: ['E2']
    */
    static void TestConcurrentWriteTo_sched_util_clamp_min_Node1() {
        LOG_START

        std::string testResourceName = "/proc/sys/kernel/sched_util_clamp_min";
        int32_t testResourceOriginalValue = 1024;

        // Check the original value for the Resource
        std::string value = AuxRoutines::readFromFile(testResourceName);
        std::cout<<"["<<__LINE__<<"]"<<" sched_util_clamp_min Original Value: "<<value<<std::endl;
        int32_t originalValue = C_STOI(value);

        if(originalValue == -1) {
            // Node does not exist on test device, can't proceed with this test
            std::cout<<"["<<__LINE__<<"]"<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
            return;
        }

        assert(originalValue == testResourceOriginalValue);

        int32_t rc = fork();
        if(rc == 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = GENERATE_RESOURCE_ID(8, 0);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 887;

            int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            exit(EXIT_SUCCESS);

        } else if(rc > 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = GENERATE_RESOURCE_ID(8, 0);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 799;

            int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            // Verify that the higher of the two configured values, i.e. 887 takes
            // effect on the Resource Node.
            std::this_thread::sleep_for(std::chrono::seconds(1));

            // Check if the new value was successfully written to the node
            value = AuxRoutines::readFromFile(testResourceName);
            int32_t newValue = C_STOI(value);
            assert(newValue == 887);

            std::this_thread::sleep_for(std::chrono::seconds(6));

            // Wait for the Request to expire, check if the value resets
            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == originalValue);

            wait(nullptr);
        }

        LOG_END
    }

    /**
    * API under test: Tune / Untune
    * - Issue 2 Concurrent Resource Tuner Resource Provisioning Requests, to modify the Resource
    *   sched_util_clamp_min
    * - Verify the Resource Node is Correctly updated to the higher of the 2 values,
    *   as the Resource has the "higher-is-better" policy.
    * - Here the Requests don't have the same duration, and the Request with a smaller config value
    *   has a higher duration.
    * - i.e. R1 (v1, d1) and R2(v2, d2) where v1 > v2 and d1 < d2
    * - Verify that the Resource Node is updated to v1 initially.
    * - Verify that the Resource Node is updated to v2 once R1 expires.
    * - Verify that the Resource Node is reset once both the Requests Expire.
    * - Note these Tests need to be run with Root Privleges (sudo)
    * Cross-Reference id: ['E3']
    */
    static void TestConcurrentWriteTo_sched_util_clamp_min_Node2() {
        LOG_START

        std::string testResourceName = "/proc/sys/kernel/sched_util_clamp_min";
        int32_t testResourceOriginalValue = 1024;

        // Check the original value for the Resource
        std::string value = AuxRoutines::readFromFile(testResourceName);
        std::cout<<"["<<__LINE__<<"]"<<" sched_util_clamp_min Original Value: "<<value<<std::endl;
        int32_t originalValue = C_STOI(value);

        if(originalValue == -1) {
            // Node does not exist on test device, can't proceed with this test
            std::cout<<"["<<__LINE__<<"]"<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
            return;
        }

        assert(originalValue == testResourceOriginalValue);

        int32_t rc = fork();
        if(rc == 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = GENERATE_RESOURCE_ID(8, 0);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 887;

            int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            exit(EXIT_SUCCESS);

        } else if(rc > 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = GENERATE_RESOURCE_ID(8, 0);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 799;

            int64_t handle = tuneResources(15000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            // Verify that the higher of the two configured values, i.e. 887 takes
            // effect on the Resource Node.
            std::this_thread::sleep_for(std::chrono::seconds(1));

            // Check if the new value was successfully written to the node
            value = AuxRoutines::readFromFile(testResourceName);
            int32_t newValue = C_STOI(value);
            assert(newValue == 887);

            std::this_thread::sleep_for(std::chrono::seconds(6));

            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == 799);

            std::this_thread::sleep_for(std::chrono::seconds(10));

            // Wait for the Request to expire, check if the value resets
            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == originalValue);

            wait(nullptr);
        }

        LOG_END
    }

  /**
    * API under test: Tune / Untune
    * - Issue a Resource Tuner Resource Provisioning Request, to modify the Resource
    *   sched_util_clamp_min for an infinite duration.
    * - Verify the Resource Node is Correctly updated
    * - Send an Untune Request, to reset the Resource Node to it's original value.
    * - Verify that the Resource Node is correctly reset.
    * - Note these Tests need to be run with Root Privleges (sudo)
    * Cross-Reference id: ['E4']
    */
    static void TestWriteTo_sched_util_clamp_min_NodeAndUntuning() {
        LOG_START

        std::string testResourceName = "/proc/sys/kernel/sched_util_clamp_min";
        int32_t testResourceOriginalValue = 1024;

        // Check the original value for the Resource
        std::string value = AuxRoutines::readFromFile(testResourceName);
        std::cout<<"["<<__LINE__<<"]"<<" sched_util_clamp_min Original Value: "<<value<<std::endl;
        int32_t originalValue = C_STOI(value);

        if(originalValue == -1) {
            // Node does not exist on test device, can't proceed with this test
            std::cout<<"["<<__LINE__<<"]"<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
            return;
        }

        assert(originalValue == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(8, 0);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 994;

        int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(1));

        // Check if the new value was successfully written to the node
        value = AuxRoutines::readFromFile(testResourceName);
        int32_t newValue = C_STOI(value);
        assert(newValue == 994);

        untuneResources(handle);
        std::this_thread::sleep_for(std::chrono::seconds(2));

        // Wait for the Request to expire, check if the value resets
        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == originalValue);

        LOG_END
    }

    /**
    * API under test: Tune / Untune
    * - Issue 2 Concurrent Resource Tuner Resource Provisioning Requests, to modify the Resource
    *   sched_util_clamp_min from different Clients
    * - Here the Requests are submitted with different Priorities
    * - Verify the Resource Node is Correctly updated to the Config Value specified by
    *   the Request with the higher priority
    * - Verify that the Resource Node is reset once the Requests Expire (here both the Requests,
    *   have exactly the same duration).
    * - Note these Tests need to be run with Root Privleges (sudo)
    * Cross-Reference id: ['E5']
    */
    static void TestConcurrentWriteTo_sched_util_clamp_min_Node3() {
        LOG_START

        std::string testResourceName = "/proc/sys/kernel/sched_util_clamp_min";
        int32_t testResourceOriginalValue = 1024;

        // Check the original value for the Resource
        std::string value = AuxRoutines::readFromFile(testResourceName);
        std::cout<<"["<<__LINE__<<"]"<<" sched_util_clamp_min Original Value: "<<value<<std::endl;
        int32_t originalValue = C_STOI(value);

        if(originalValue == -1) {
            // Node does not exist on test device, can't proceed with this test
            std::cout<<"["<<__LINE__<<"]"<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
            return;
        }

        assert(originalValue == testResourceOriginalValue);

        int32_t rc = fork();
        if(rc == 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = GENERATE_RESOURCE_ID(8, 0);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 744;

            int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            exit(EXIT_SUCCESS);

        } else if(rc > 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = GENERATE_RESOURCE_ID(8, 0);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 801;

            int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_LOW, 1, resourceList);

            // Verify that the value specified by the Request with the higher
            // priority takes effect on the Resource Node
            std::this_thread::sleep_for(std::chrono::seconds(1));

            // Check if the new value was successfully written to the node
            value = AuxRoutines::readFromFile(testResourceName);
            int32_t newValue = C_STOI(value);
            assert(newValue == 744);

            std::this_thread::sleep_for(std::chrono::seconds(6));

            // Wait for the Request to expire, check if the value resets
            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == originalValue);

            wait(nullptr);
        }

        LOG_END
    }

    static void TestWriteTo_scaling_min_freq_Node1() {
        LOG_START

        std::string testResourceName = "/sys/devices/system/cpu/cpufreq/policy0/scaling_min_freq";

        std::string originalValueString = AuxRoutines::readFromFile(testResourceName);
        std::cout<<"["<<__LINE__<<"]"<<" policy0/scaling_min_freq Original Value: "<<originalValueString<<std::endl;
        int32_t originalValue = C_STOI(originalValueString);

        if(originalValue == -1) {
            // Node does not exist on test device, can't proceed with this test
            std::cout<<"["<<__LINE__<<"]"<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
            return;
        }

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = 0x00040000;
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 1504993;

        int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(1));

        // Check if the new value was successfully written to the node
        std::string value = AuxRoutines::readFromFile(testResourceName);
        int32_t newValue = C_STOI(value);
        assert(newValue == 1504993);

        std::this_thread::sleep_for(std::chrono::seconds(6));

        // Wait for the Request to expire, check if the value resets
        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == originalValue);

        LOG_END
    }

    static void TestWriteTo_scaling_min_freq_Node2() {
        LOG_START

        std::string testResourceName = "/sys/devices/system/cpu/cpufreq/policy1/scaling_min_freq";

        std::string originalValueString = AuxRoutines::readFromFile(testResourceName);
        std::cout<<"["<<__LINE__<<"]"<<" policy1/scaling_min_freq Original Value: "<<originalValueString<<std::endl;
        int32_t originalValue = C_STOI(originalValueString);

        if(originalValue == -1) {
            // Node does not exist on test device, can't proceed with this test
            std::cout<<"["<<__LINE__<<"]"<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
            return;
        }

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = 0x00040001;
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 1504993;

        int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(1));

        // Check if the new value was successfully written to the node
        std::string value = AuxRoutines::readFromFile(testResourceName);
        int32_t newValue = C_STOI(value);
        assert(newValue == 1504993);

        std::this_thread::sleep_for(std::chrono::seconds(6));

        // Wait for the Request to expire, check if the value resets
        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == originalValue);

        LOG_END
    }

    // More involved than writing to sched_util_clamp_min_Node node
    // Since the condition sched_util_clamp_min_Node <= sched_util_clamp_max_Node should always
    // should always be true, else kernel will reject the write request.
    // Special care to be given while untuning as well, use Reverse Untune Order for
    // such request.
    // By defaults both nodes have a value of 1024, to change the value of sched_util_clamp_max_Node
    // to say 880, we'll first need to lower sched_util_clamp_min_Node to a value < 880.
    static void TestWriteTo_sched_util_clamp_max_Node1() {
        LOG_START

        std::string testResourceName1 = "/proc/sys/kernel/sched_util_clamp_min";
        int32_t testResourceOriginalValue = 1024;

        // Check the original value for the Resource
        std::string value = AuxRoutines::readFromFile(testResourceName1);
        std::cout<<"["<<__LINE__<<"]"<<" sched_util_clamp_min Original Value: "<<value<<std::endl;
        int32_t originalValue1 = C_STOI(value);

        if(originalValue1 == -1) {
            // Node does not exist on test device, can't proceed with this test
            std::cout<<"["<<__LINE__<<"]"<<"Node: "<<testResourceName1<<" not found on test device, Aborting Test Case"<<std::endl;
            return;
        }

        assert(originalValue1 == testResourceOriginalValue);

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = GENERATE_RESOURCE_ID(8, 0);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 718;

        int64_t handle = tuneResources(25000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::this_thread::sleep_for(std::chrono::seconds(1));

        // Check if the new value was successfully written to the node
        value = AuxRoutines::readFromFile(testResourceName1);
        int32_t newValue = C_STOI(value);
        assert(newValue == 718);

        // Create another request to tune max node
        std::string testResourceName2 = "/proc/sys/kernel/sched_util_clamp_max";

        // Check the original value for the Resource
        value = AuxRoutines::readFromFile(testResourceName1);
        std::cout<<"["<<__LINE__<<"]"<<" sched_util_clamp_max Original Value: "<<value<<std::endl;
        int32_t originalValue2 = C_STOI(value);

        if(originalValue2 == -1) {
            // Node does not exist on test device, can't proceed with this test
            std::cout<<"["<<__LINE__<<"]"<<"Node: "<<testResourceName1<<" not found on test device, Aborting Test Case"<<std::endl;
            std::this_thread::sleep_for(std::chrono::seconds(30));
            return;
        }

        assert(originalValue2 == testResourceOriginalValue);

        SysResource* resourceList2 = new SysResource[1];
        resourceList2[0].mResCode = GENERATE_RESOURCE_ID(8, 1);
        resourceList2[0].mNumValues = 1;
        resourceList2[0].mResValue.value = 880;

        handle = tuneResources(7000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList2);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        // Check if the new value was successfully written to the node
        value = AuxRoutines::readFromFile(testResourceName2);
        newValue = C_STOI(value);
        assert(newValue == 880);

        std::this_thread::sleep_for(std::chrono::seconds(30));

        // Wait for the Request to expire, check if the value resets
        value = AuxRoutines::readFromFile(testResourceName1);
        newValue = C_STOI(value);
        assert(newValue == originalValue1);

        value = AuxRoutines::readFromFile(testResourceName2);
        newValue = C_STOI(value);
        assert(newValue == originalValue2);

        LOG_END
    }

    static void RunTestGroup() {
        std::cout<<"\nRunning tests from the Group: "<<__testGroupName<<std::endl;

        RUN_TEST(TestWriteTo_sched_util_clamp_min_Node)
        RUN_TEST(TestConcurrentWriteTo_sched_util_clamp_min_Node1)
        RUN_TEST(TestConcurrentWriteTo_sched_util_clamp_min_Node2)
        RUN_TEST(TestWriteTo_sched_util_clamp_min_NodeAndUntuning)
        RUN_TEST(TestConcurrentWriteTo_sched_util_clamp_min_Node3)
        RUN_TEST(TestWriteTo_scaling_min_freq_Node1)
        RUN_TEST(TestWriteTo_scaling_min_freq_Node2)
        RUN_TEST(TestWriteTo_sched_util_clamp_max_Node1)

        std::cout<<"\n\nAll tests from the Group: "<<__testGroupName<<", Ran Successfully"<<std::endl;
    }
}

namespace SignalApplicationTests {
   /*
    * Description:
    * This Section contains tests which aim to verify the correctness of Signal (GRAB / FREE) Application.
    * The tests are enumerated as follows:
    * => Single Client - Single Signal Tuning [A]
    */
    std::string __testGroupName = "Signal Application Checks";

   /**
    * API under test: tuneSignal
    * - A client tries to tune a Signal, which tunes a Single Resource
    * - Verified the Resource Node is updated to the configured value
    * - Verify that the Resource Node is reset once the Signal timeouts.
    * Cross-Reference id: [A]
    */
    static void TestSingleClientTuneSignal1() {
        LOG_START

        std::string testResourceName = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/sched_util_clamp_min";
        int32_t testResourceOriginalValue = 300;

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName);
        originalValue = C_STOI(value);
        assert(originalValue == testResourceOriginalValue);

        int64_t handle =
            tuneSignal(0x800d0004, 5000, RequestPriority::REQ_PRIORITY_HIGH, "app-name", "scenario-zip", 0, nullptr);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 917);

        std::this_thread::sleep_for(std::chrono::seconds(8));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == testResourceOriginalValue);

        LOG_END
    }

   /**
    * API under test: tuneSignal
    * - A client tries to tune a Signal, which tunes multiple Resources
    * - Verified the Resource Node is updated to the configured value
    * - Verify that the Resource Node is reset once the Signal timeouts.
    * Cross-Reference id: [A]
    */
    static void TestSingleClientTuneSignal2() {
        LOG_START

        std::string testResourceName1 = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/sched_util_clamp_min";
        std::string testResourceName2 = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/sched_util_clamp_max";
        std::string testResourceName3 = "/etc/resource-tuner/tests/Configs/ResourceSysFsNodes/scaling_max_freq";

        int originalValues[] = {300, 684, 114};

        std::string value;
        int32_t originalValue, newValue;

        value = AuxRoutines::readFromFile(testResourceName1);
        originalValue = C_STOI(value);
        assert(originalValue == originalValues[0]);

        value = AuxRoutines::readFromFile(testResourceName2);
        originalValue = C_STOI(value);
        assert(originalValue == originalValues[1]);

        value = AuxRoutines::readFromFile(testResourceName3);
        originalValue = C_STOI(value);
        assert(originalValue == originalValues[2]);

        int64_t handle =
            tuneSignal(0x800d0005, 5000, RequestPriority::REQ_PRIORITY_HIGH, "app-name", "scenario-zip", 0, nullptr);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName1);
        newValue = C_STOI(value);
        assert(newValue == 883);

        value = AuxRoutines::readFromFile(testResourceName2);
        newValue = C_STOI(value);
        assert(newValue == 920);

        value = AuxRoutines::readFromFile(testResourceName3);
        newValue = C_STOI(value);
        assert(newValue == 1555);

        std::this_thread::sleep_for(std::chrono::seconds(8));

        value = AuxRoutines::readFromFile(testResourceName1);
        originalValue = C_STOI(value);
        assert(originalValue == originalValues[0]);

        value = AuxRoutines::readFromFile(testResourceName2);
        originalValue = C_STOI(value);
        assert(originalValue == originalValues[1]);

        value = AuxRoutines::readFromFile(testResourceName3);
        originalValue = C_STOI(value);
        assert(originalValue == originalValues[2]);

        LOG_END
    }

    static void RunTestGroup() {
        std::cout<<"\nRunning tests from the Group: "<<__testGroupName<<std::endl;

        RUN_TEST(TestSingleClientTuneSignal1);
        RUN_TEST(TestSingleClientTuneSignal2);

        std::cout<<"\n\nAll tests from the Group: "<<__testGroupName<<", Ran Successfully"<<std::endl;
    }
}

namespace CGroupApplicationTests {
    std::string __testGroupName = "CGroup Application Checks";

    static void TestWriteAndReset1() {
        LOG_START

        std::string testResourceName = "/sys/fs/cgroup/audio-cgroup/cpu.uclamp.min";

        std::string originalValueString = AuxRoutines::readFromFile(testResourceName);
        int32_t originalValue = C_STOI(originalValueString);

        SysResource* resourceList1 = new SysResource[1];
        resourceList1[0].mResCode = 0x00090007;
        resourceList1[0].mNumValues = 2;
        resourceList1[0].mResValue.values = new int32_t[2];
        resourceList1[0].mResValue.values[0] = 1;
        resourceList1[0].mResValue.values[1] = 52;
        int64_t handle = tuneResources(25000, RequestPriority::REQ_PRIORITY_LOW, 1, resourceList1);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        SysResource* resourceList = new SysResource[1];
        resourceList[0].mResCode = 0x00090007;
        resourceList[0].mNumValues = 2;
        resourceList[0].mResValue.values = new int32_t[2];
        resourceList[0].mResValue.values[0] = 1;
        resourceList[0].mResValue.values[1] = 57;
        handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

        std::string value;
        int32_t newValue;

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 57);

        std::this_thread::sleep_for(std::chrono::seconds(8));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == 52);

        std::this_thread::sleep_for(std::chrono::seconds(20));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        assert(newValue == originalValue);

        LOG_END
    }

    static void TestWriteAndReset2() {
        LOG_START

        std::string testResourceName = "/sys/fs/cgroup/audio-cgroup/cpu.uclamp.min";

        std::string originalValueString = AuxRoutines::readFromFile(testResourceName);
        int32_t originalValue = C_STOI(originalValueString);

        int32_t rc = fork();
        if(rc == 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = 0x00090007;
            resourceList[0].mNumValues = 2;
            resourceList[0].mResValue.values = new int32_t[2];
            resourceList[0].mResValue.values[0] = 1;
            resourceList[0].mResValue.values[1] = 53;

            int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            exit(EXIT_SUCCESS);

        } else if(rc > 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = 0x00090007;
            resourceList[0].mNumValues = 2;
            resourceList[0].mResValue.values = new int32_t[2];
            resourceList[0].mResValue.values[0] = 1;
            resourceList[0].mResValue.values[1] = 57;

            int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            std::string value;
            int32_t newValue;

            std::this_thread::sleep_for(std::chrono::seconds(2));

            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == 53);

            std::this_thread::sleep_for(std::chrono::seconds(10));

            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == originalValue);

            wait(nullptr);
        }

        LOG_END
    }

    static void TestWriteAndReset3() {
        LOG_START

        std::string testResourceName = "/sys/fs/cgroup/audio-cgroup/cpu.uclamp.max";

        std::string originalValueString = AuxRoutines::readFromFile(testResourceName);
        std::cout<<"["<<__LINE__<<"]"<<" cpu.uclamp.max Original Value: "<<originalValueString<<std::endl;
        int32_t originalValue = C_STOI(originalValueString);

        int32_t rc = fork();
        if(rc == 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = 0x00090008;
            resourceList[0].mNumValues = 2;
            resourceList[0].mResValue.values = new int32_t[2];
            resourceList[0].mResValue.values[0] = 1;
            resourceList[0].mResValue.values[1] = 75;

            int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            exit(EXIT_SUCCESS);

        } else if(rc > 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = 0x00090008;
            resourceList[0].mNumValues = 2;
            resourceList[0].mResValue.values = new int32_t[2];
            resourceList[0].mResValue.values[0] = 1;
            resourceList[0].mResValue.values[1] = 68;

            int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            std::string value;
            int32_t newValue;

            std::this_thread::sleep_for(std::chrono::seconds(2));

            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue == 75);

            std::this_thread::sleep_for(std::chrono::seconds(10));

            value = AuxRoutines::readFromFile(testResourceName);
            std::cout<<"["<<__LINE__<<"]"<<" cpu.uclamp.max Reset Value: "<<value<<std::endl;
            newValue = C_STOI(value);
            if(newValue != -1 && originalValue != -1) {
                assert(newValue == originalValue);
            }

            wait(nullptr);
        }

        LOG_END
    }

    static void TestWriteAndReset4() {
        LOG_START

        std::string testResourceName = "/sys/fs/cgroup/audio-cgroup/memory.max";

        std::string originalValueString = AuxRoutines::readFromFile(testResourceName);
        std::cout<<"["<<__LINE__<<"]"<<" memory.max Original Value: "<<originalValueString<<std::endl;
        int32_t originalValue = C_STOI(originalValueString);

        int32_t rc = fork();
        if(rc == 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = 0x0009000a;
            resourceList[0].mNumValues = 2;
            resourceList[0].mResValue.values = new int32_t[2];
            resourceList[0].mResValue.values[0] = 1;
            resourceList[0].mResValue.values[1] = 1224 * 1024;

            int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            exit(EXIT_SUCCESS);

        } else if(rc > 0) {
            SysResource* resourceList = new SysResource[1];
            resourceList[0].mResCode = 0x0009000a;
            resourceList[0].mNumValues = 2;
            resourceList[0].mResValue.values = new int32_t[2];
            resourceList[0].mResValue.values[0] = 1;
            resourceList[0].mResValue.values[1] = 950 * 1024;

            int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);

            std::string value;
            int32_t newValue;

            std::this_thread::sleep_for(std::chrono::seconds(2));

            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            assert(newValue > 950 * 1024);
            assert(newValue <= 1224 * 1024);

            std::this_thread::sleep_for(std::chrono::seconds(10));

            value = AuxRoutines::readFromFile(testResourceName);
            std::cout<<"["<<__LINE__<<"]"<<" memory.max Reset Value: "<<value<<std::endl;
            newValue = C_STOI(value);
            if(newValue != -1 && originalValue != -1) {
                assert(newValue == originalValue);
            }

            wait(nullptr);
        }

        LOG_END
    }

    // Multiple CGroups in a single Request
    static void TestWriteAndReset5() {
        LOG_START

        std::string testResourceName1 = "/sys/fs/cgroup/camera-cgroup/cpu.uclamp.min";
        std::string testResourceName2 = "/sys/fs/cgroup/audio-cgroup/cpu.uclamp.min";

        std::string originalValueString = AuxRoutines::readFromFile(testResourceName1);
        std::cout<<"["<<__LINE__<<"]"<<" 0) cpu.uclamp.min Original Value: "<<originalValueString<<std::endl;
        int32_t originalValue1 = C_STOI(originalValueString);

        originalValueString = AuxRoutines::readFromFile(testResourceName2);
        std::cout<<"["<<__LINE__<<"]"<<" 1) cpu.uclamp.min Original Value: "<<originalValueString<<std::endl;
        int32_t originalValue2 = C_STOI(originalValueString);

        SysResource* resourceList = new SysResource[2];
        resourceList[0].mResCode = 0x00090007;
        resourceList[0].mNumValues = 2;
        resourceList[0].mResValue.values = new int32_t[2];
        resourceList[0].mResValue.values[0] = 0;
        resourceList[0].mResValue.values[1] = 55;

        resourceList[1].mResCode = 0x00090007;
        resourceList[1].mNumValues = 2;
        resourceList[1].mResValue.values = new int32_t[2];
        resourceList[1].mResValue.values[0] = 1;
        resourceList[1].mResValue.values[1] = 58;

        int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_LOW, 2, resourceList);

        std::string value;
        int32_t newValue;

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName1);
        newValue = C_STOI(value);
        assert(newValue == 55);

        value = AuxRoutines::readFromFile(testResourceName2);
        newValue = C_STOI(value);
        assert(newValue == 58);

        std::this_thread::sleep_for(std::chrono::seconds(10));

        value = AuxRoutines::readFromFile(testResourceName1);
        newValue = C_STOI(value);
        if(newValue != -1 && originalValue1 != -1) {
            assert(newValue == originalValue1);
        }

        value = AuxRoutines::readFromFile(testResourceName2);
        newValue = C_STOI(value);
        if(newValue != -1 && originalValue2 != -1) {
            assert(newValue == originalValue2);
        }

        LOG_END
    }

    static void RunTestGroup() {
        std::cout<<"\nRunning tests from the Group: "<<__testGroupName<<std::endl;

        TestWriteAndReset1();
        TestWriteAndReset2();
        TestWriteAndReset3();
        TestWriteAndReset4();
        TestWriteAndReset5();

        std::cout<<"\n\nAll tests from the Group: "<<__testGroupName<<", Ran Successfully"<<std::endl;
    }
}

int32_t main(int32_t argc, const char* argv[]) {
    // Run the Tests
    RUN_TEST(TestHandleGeneration)

    // Request-Verification Tests
    ResourceTuningRequestVerification::RunTestGroup();
    SignalVerification::RunTestGroup();

    // Request Application Tests
    RequestApplicationTests::RunTestGroup();

    // Tests on Real Sysfs Nodes (QLI)
    SystemSysfsNodesTests::RunTestGroup();

    SignalApplicationTests::RunTestGroup();

    CGroupApplicationTests::RunTestGroup();

    return 0;
}
